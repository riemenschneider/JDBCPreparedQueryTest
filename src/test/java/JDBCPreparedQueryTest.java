import static io.vertx.core.Future.succeededFuture;

import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.RunTestOnContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.PoolOptions;
import io.vertx.sqlclient.PreparedQuery;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.Tuple;

@RunWith(VertxUnitRunner.class)
public class JDBCPreparedQueryTest {
	
    @Rule
    public RunTestOnContext runTestOnContextRule = new RunTestOnContext();
    
	@Test
	public void test(TestContext context) {
        final Vertx vertx = runTestOnContextRule.vertx();
        Future.succeededFuture(JDBCPool.pool(vertx, 
                new JDBCConnectOptions()
                        .setJdbcUrl("jdbc:hsqldb:mem:.")
                        .setAutoGeneratedKeys(true),
                new PoolOptions()
        ))
                .compose(pool -> pool.query("CREATE TABLE test (id INT, data BIGINT)").execute().map(pool))
                .compose(pool -> {
                    PreparedQuery<RowSet<Row>> query = pool.preparedQuery("INSERT INTO test (id, data) VALUES (?, ?)");
                    return succeededFuture()
                            .compose(ignore -> query.execute(Tuple.of(1, 42l)))
                            .compose(ignore -> query.execute(Tuple.of(2, 0l)))
                            .compose(ignore -> query.execute(Tuple.of(3, (Long)null)))
                            .map(pool);
                })
                .compose(pool -> pool.close())
                .onComplete(context.asyncAssertSuccess());
	}

}
